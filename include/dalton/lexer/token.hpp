#pragma once
#include <dalton/core/location.hpp>

#include <string>

/**
 * @brief Contains components related to the lexing (tokenization) phase of the
 * compiler.
 */
namespace dalton::lexer {

/**
 * @brief Enumeration of all possible token types recognized by the lexer.
 * * TODO: Define specific token types (e.g., Identifier, NumberLiteral,
 * Keyword_If, etc.) here.
 */
enum class TokenType {};

/**
 * @brief Represents a single token generated by the lexer.
 * * A token is the smallest meaningful unit in the source code, carrying
 * information about its type, location in the source file, and its raw value.
 */
struct Token {
  /**
   * @brief The category or kind of the token (e.g., identifier, operator,
   * keyword).
   */
  TokenType type;

  /**
   * @brief The precise location of the token within the source file.
   * * This is used for error reporting and diagnostics.
   */
  core::SourceLocation location;

  /**
   * @brief The raw string value of the token as it appears in the source code.
   * * For example, for a NUMBER_LITERAL token, this would be the actual number
   * string ("123").
   */
  std::string value;

  /**
   * @brief Constructs a new Token object.
   * * @param type The TokenType of the token.
   * @param location The core::SourceLocation where the token was found.
   * @param value The string value of the token.
   */
  Token(TokenType type, core::SourceLocation location, std::string value);
};

} // namespace dalton::lexer
