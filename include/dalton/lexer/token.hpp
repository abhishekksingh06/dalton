#pragma once
#include <dalton/core/location.hpp>

#include <string>

/**
 * @brief Contains components related to the lexing (tokenization) phase of the
 * compiler.
 */
namespace dalton::lexer {
/**
 * @brief Enumeration of all possible token types recognized by the lexer.
 */
enum class TokenType {
  // --- Symbols ---
  LeftParen,    // (
  RightParen,   // )
  LeftBrace,    // {
  RightBrace,   // }
  LeftBracket,  // [
  RightBracket, // ]
  Comma,        // ,
  Semicolon,    // ;
  Colon,        // :
  Dot,          // .
  DotDot,       // ..
  DotDotDot,    // ...
  Question,     // ?
  Arrow,        // ->

  // --- Assignment & compound assignment ---
  Equal,        // =
  PlusEqual,    // +=
  MinusEqual,   // -=
  StarEqual,    // *=
  SlashEqual,   // /=
  PercentEqual, // %=
  CaretEqual,   // ^=

  // --- Arithmetic ---
  Plus,    // +
  Minus,   // -
  Star,    // *
  Slash,   // /
  Percent, // %

  // --- Comparisons ---
  EqualEqual,   // ==
  BangEqual,    // !=
  Less,         // <
  LessEqual,    // <=
  Greater,      // >
  GreaterEqual, // >=

  // --- Logical & Bitwise ---
  Bang,       // !
  AndAnd,     // &&
  OrOr,       // ||
  Amp,        // &
  Pipe,       // |
  Caret,      // ^
  Tilde,      // ~
  ShiftLeft,  // <<
  ShiftRight, // >>

  // --- Literals ---
  Identifier,
  Number,
  StringLiteral,
  CharLiteral,

  // --- End of file ---
  Eof,

  // --- Declarations & modifiers ---
  KwLet,
  KwMut,
  KwConst,
  KwFn,
  KwStruct,
  KwEnum,
  KwTrait,
  KwType,
  KwScope,
  KwExternal,
  KwPub,

  // --- Modules ---
  KwImport,

  // --- Generics / constraints ---
  KwWhere,

  // --- Control flow ---
  KwIf,
  KwThen,
  KwElse,
  KwSwitch,
  KwCase,
  KwDefault,
  KwFor,
  KwWhile,
  KwLoop,
  KwBreak,
  KwContinue,
  KwReturn,
  KwDefer,

  // --- Patterns / optionals / literals ---
  KwIn,
  KwAs,
  KwNil,
  KwTrue,
  KwFalse,

  // --- Error handling ---
  KwTry,
  KwCatch,

  // --- Compile-time keyword ---
  KwCompiletime,

  // --- Primitive types: integers ---
  KwI8,
  KwI16,
  KwI32,
  KwI64,
  KwI128,
  KwI256,
  KwIsize,

  KwU8,
  KwU16,
  KwU32,
  KwU64,
  KwU128,
  KwU256,
  KwUsize,

  // --- Primitive types: floating ---
  KwF32,
  KwF64,

  // --- Primitive types: other ---
  KwChar,
  KwStr,
  KwBool,
  KwMap
};
/**
 * @brief Represents a single token generated by the lexer.
 * * A token is the smallest meaningful unit in the source code, carrying
 * information about its type, location in the source file, and its raw value.
 */
struct Token {
  /**
   * @brief The category or kind of the token (e.g., identifier, operator,
   * keyword).
   */
  TokenType type;

  /**
   * @brief The precise location of the token within the source file.
   * * This is used for error reporting and diagnostics.
   */
  core::SourceLocation location;

  /**
   * @brief The raw string value of the token as it appears in the source code.
   * * For example, for a NUMBER_LITERAL token, this would be the actual number
   * string ("123").
   */
  std::string lexeme;

  /**
   * @brief Constructs a new Token object.
   * * @param type The TokenType of the token.
   * @param location The core::SourceLocation where the token was found.
   * @param value The string value of the token.
   */
  Token(TokenType type, core::SourceLocation location, std::string value);
};
} // namespace dalton::lexer
